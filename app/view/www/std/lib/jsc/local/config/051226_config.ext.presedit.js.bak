var CMLC, EH, Box;
var CUSTOM_ELEM_PREPROPS = 'position:relative;display:block;border-width:1px;border-style:solid;padding:3px;height:20px;font-size:10px;margin-bottom:5px;'+
                           'border-color:#000000;overflow:hidden';
var CUSTOM_ELEM_AVAILPROPS = 'BGR*,FGR*,LTA*,BRD*,TXT*,MRG*';

window.onload = function()
{
  document.body.onmousemove = function(e) { routeBodyMove(e) };
  
  RGB.setupGUI('HEX');
  
  var tagmc_type = new Inp_Radio('frm_tagm_create', 'tagm_type');
  tagmc_type.add('class', 1, 'rad_class');
  tagmc_type.add('id', 0, 'rad_id');
  
  // Setup element handler.
  EH = new CML_ElemHandler(document.getElementById('frm_cssProps'));
  EH.addElem('a',       'class', 'a',       0,  'display:inline;font-weight:bold;text-decoration:none;font-size:10px;padding:0px;color:#281100;'+
                                                'background-color:transparent',
                                                'BGR*,FGR*,TXT*,BRD*,background-color,padding');
  EH.addElem('a',       'class', 'a:hover', 0,  'display:inline;font-weight:bold;text-decoration:none;font-size:10px;padding:0px;color:#8C3F0F;'+
                                                'background-color:transparent',
                                                'BGR*,FGR*,TXT*,BRD*,background-color,padding');
  EH.addElem('big',     'class', 'big',     0,  '', null);
  EH.addElem('div',     'class', 'body',    0,  'position:relative;display:block;overflow:hidden;height:200px;padding:5px',
                                                'height,BGR*,FGR*,TXT*,padding');
  EH.addElem('span',    'class', 'b',       0,  'font-weight:bold', null);
  EH.addElem('span',    'class', 'i',       0,  'font-style:italic', null);
  EH.addElem('span',    'class', 's',       0,  'text-decoration:line-through', null);
  EH.addElem('span',    'class', 'u',       0,  'text-decoration:underline', null);
  EH.addElem('div',     'class', 'center',  0,  'text-align:center', null);
  EH.addElem('div',     'class', 'right',   0,  'text-align:right', null);
  EH.addElem('hr',      'class', 'hr',      1,  'background-color:#000000;border-style:none;height:1px;width:300px;', 'background-color,width,height');
  EH.addElem('br',      'class', 'br',      1,  '', null);
  EH.addElem('div',     'class', 'test',    0,  CUSTOM_ELEM_PREPROPS, CUSTOM_ELEM_AVAILPROPS);
//  EH.addElem('div',     'id',    'id1',     0,  CUSTOM_ELEM_PREPROPS, CUSTOM_ELEM_AVAILPROPS);
  EH.addElem('div',     'id',    'id1',     0,  'display:block;border-width:1px;border-style:solid;padding:3px;height:100px;font-size:10px;'+
                                                'border-color:#000000;position:absolute;background-color:#789789;width:100px', CUSTOM_ELEM_AVAILPROPS);
  EH.addElem('div',     'id',    'id2',     0,  'display:block;border-width:1px;border-style:solid;padding:3px;height:100px;font-size:10px;'+
                                                'border-color:#000000;position:absolute;background-color:#789789;width:100px', CUSTOM_ELEM_AVAILPROPS);
  EH.Elems.get('id2').touched = true;
  EH.updateGUI('test');
  
  // Setup compiler sub-classes:
  Box = new BoxManager();
  
  // Setup and run compiler preview.
  CMLC = new CML_Compiler(document.getElementById('pe_data'), document.getElementById('pe_prev'));
  CMLC.updatePreview();
};

function pcpl() { CMLC.updatePreview(); }

/**
 * COPYRIGHT - Copyright 2002. All rights reserved. - This notice must remain untouched.
 * File: jsc_local.rgb-map.php
 * 
 * --- Description ---
 * The first section is the javascript compilator for user presentations.
 * The second section contains a class for the color-handler.
 * 
 * --- Copyright notice ---
 * Copying, modifying, using or distributing this script without the authors permission is an act of a true lamer.
 * Want to use this script? Fine, just ask. Although the purpose must be non-commercial.
 * 
 * --- External sources ---
 * http://gimp-savvy.com/BOOK/index.html?node52.html
 * http://www.pcigeomatics.com/cgi-bin/pcihlp/RGB
 * 
 * Last modified: 2005.06.15
 * Author: Lukas Kalinski (lukas@cylab.se)
*/

function RGB_Map()
{
  this.scan = false;
  
  this.sliderSizeX = 147;
  this.mapSizeX = 150;
  this.mapSizeY = 152;
  this.mapOffsetX = 5;
  this.mapOffsetY = 5;
  this.evX = 0;
  this.evY = 0;
    
  this.HEX = "007878"; // Predefined color, maybe random in the future?
  this.R = 0;
  this.G = 0;
  this.B = 0;
  this.whiteness = 0;
  this.S = 0;
  this.V = 0;
  this.H = 0;
  
  this.logEvent = function(ev)
  {
    ev = new Event(ev);
    this.evX = ev.objPosX;
    this.evY = ev.objPosY;
  };
  
  this.setupGUI = function(c)
  {
    switch(c)
    {
      case "RGB":
        this.HEXfromRGB();
        this.HSVfromRGB();
        break;
      case "HSV":
        this.RGBfromHSV();
        this.HEXfromRGB();
        break;
      case "HEX":
        this.RGBfromHEX();
        this.HSVfromRGB();
        break;
    }
    this.refreshGUI();
  };
  
  this.refreshGUI = function()
  {
    document.getElementById('rgbPreview').style.background = "#"+this.HEX;
    ref = document.getElementById('frmColorMap');
    ref.H.value = Math.round(this.H);
    ref.S.value = Math.round(this.S * 100);
    ref.V.value = Math.round(this.V * 100);
    ref.R.value = this.R;
    ref.G.value = this.G;
    ref.B.value = this.B;
    ref.HEX.value = this.HEX;
    ref.cHEX.value = "#" + this.HEX;
    
    var hPos = Math.min(Math.max(this.mapSizeX * (this.H / 360) + this.mapOffsetX, 0), this.mapSizeX + this.mapOffsetX);
    var vPos = Math.min(Math.max(this.mapSizeY * (1 - this.V) + this.mapOffsetY, 0), this.mapSizeY + this.mapOffsetY);
    var sPos = Math.min(Math.max((this.S * this.sliderSizeX) - 2, 1), 144);
    var wPos = Math.min(Math.max((this.whiteness * this.sliderSizeX) - 2, 1), 144);
    
    css_setPos('cur_h', hPos-3, null);
    css_setPos('cur_v', null, vPos-3);
    css_setPos('cur_map', hPos-5, null);
    css_setPos('cur_map', null, vPos-5);
    css_setPos('cur_s', sPos, null);
    css_setPos('cur_w', wPos, null);
  };
  
  this.scanNumericChange = function(inpObj)
  {
    var varVal = inpObj.value;
    var varMax, varSys;
    var doDiv = false;
    
    switch(inpObj.name)
    {
      case "R":
        varMax = 255;
        varSys = "RGB";
        break;
      case "G":
        varMax = 255;
        varSys = "RGB";
        break;
      case "B":
        varMax = 255;
        varSys = "RGB";
        break;
      case "H":
        varMax = 360;
        varSys = "HSV";
        break;
      case "S":
        varMax = 100;
        varSys = "HSV";
        doDiv = true;
        break;
      case "V":
        varMax = 100;
        varSys = "HSV";
        doDiv = true;
        break;
      case "HEX":
        varSys = "HEX";
        break;
    }
    if(varVal.length > 0)
    {
      var hexValidated = true;
      if(varSys == "HEX")
      {
        if(inpObj.value.match(/[0-9a-f]{6}/gi)) { this.HEX = inpObj.value; }
        else { hexValidated = false; }
      }
      else
      {
        varVal = varVal.replace(/[^0-9]/gi, "");
        if(isNaN(varVal)) { varVal = 0; }
        varVal = Math.min(varVal, varMax);
        if(doDiv) { varVal = varVal / varMax }
        eval("this." + inpObj.name + '=' + varVal);
      }
      if(hexValidated) { this.setupGUI(varSys); }
    }
  };
  
  this.startGraphicMove = function(ev, obj)
  {
    this.scan = true;
    this.scanGraphicMove(ev, obj);
  };
  
  this.scanGraphicMove = function(ev, obj)
  {
    if(this.scan)
    {
      this.logEvent(ev);
      switch(obj)
      {
        case "map":
          this.V = Math.min(Math.max(1 - ((this.evY - this.mapOffsetY) / (this.mapSizeY)), 0), 1);
          this.H = Math.min(Math.max(360 * ((this.evX - this.mapOffsetX) / this.mapSizeX), 0), 360);
          break;
        case "saturation":
          this.S = Math.min(Math.max(this.evX / this.sliderSizeX, 0), 1);
          break;
        case "whiteness":
          this.whiteness = this.evX / this.sliderSizeX;
          break;
      }
      this.setupGUI('HSV');
    }
  };
  
  this.stopGraphicMove = function()
  {
    if(this.scan) { document.getElementById('frmColorMap').HEX.focus(); } // Just to prevent this ugly select-all thing.
    this.scan = false;
  };
  
  this.HEXfromRGB = function()
  {
    function hex(n)
    {
      n = n.toString(16);
      if(n.length < 2) { n = "0" + n; }
      return n;
    }
    this.HEX = hex(this.R) + hex(this.G) + hex(this.B);
    this.HEX = this.HEX.toUpperCase();
  };
  
  this.RGBfromHEX = function()
  {
    this.R = parseInt(this.HEX.substr(0,2), 16);
    this.G = parseInt(this.HEX.substr(2,2), 16);
    this.B = parseInt(this.HEX.substr(4,2), 16);
  };
  
  this.HSVfromRGB = function()
  {
    var cMin = Math.min(Math.min(this.R, this.G), this.B);
    var cMax = Math.max(Math.max(this.R, this.G), this.B);
    
    this.S = (cMax != 0 ? ((cMax - cMin) / cMax) : 0);
    this.whiteness = 0;
    this.V = cMax / 255;
    
    if(this.R == this.G && this.G == this.B) { this.H = 0; }
    else
    {
      var delta = cMax - cMin;
      switch(cMax)
      {
        case this.R: this.H = (this.G - this.B) / delta; break;
        case this.G: this.H = 2 + ((this.B - this.R) / delta); break;
        case this.B: this.H = 4 + ((this.R - this.G) / delta); break;
      }
      this.H = this.H * 60;
      if(this.H < 0) { this.H = this.H + 360; }
    }
  };
  
  this.RGBfromHSV = function()
  {
    var hue = this.H;
    if(hue == 360) { hue = 0; }
    hue = hue / 60;
    var hueSector = Math.floor(hue);
    var hueDelta = hue - hueSector;
    var cmi = this.whiteness + (this.V * (1 - this.S));
    var cma = this.whiteness + (this.V);
    var dec = this.whiteness + (this.V * (1 - (this.S * hueDelta)));
    var inc = this.whiteness + (this.V * (1 - (this.S * (1 - hueDelta))));
    
    switch(hueSector)
    {
      case 0:  this.R = cma; this.G = inc; this.B = cmi; break;
      case 1:  this.R = dec; this.G = cma; this.B = cmi; break;
      case 2:  this.R = cmi; this.G = cma; this.B = inc; break;
      case 3:  this.R = cmi; this.G = dec; this.B = cma; break;
      case 4:  this.R = inc; this.G = cmi; this.B = cma; break;
      case 5:  this.R = cma; this.G = cmi; this.B = dec; break;
    }
    
    this.R = Math.max(Math.min(Math.round(this.R * 255), 255), 0);
    this.G = Math.max(Math.min(Math.round(this.G * 255), 255), 0);
    this.B = Math.max(Math.min(Math.round(this.B * 255), 255), 0);
  };
  
  this.copyHEX = function()
  {
    if(B.ie)
    {
      oText = document.getElementById('frmColorMap').cHEX.createTextRange();
      oText.execCommand("Copy");
    }
    else
    {
      alert("browser blaha..");
    }
  };
}

var RGB = new RGB_Map();


/**
 * Presentation compilator
 * 
 * @begin 2005-08-07
 *
 */

function tagm_go(m)
{
  var tagm_f = document.getElementById('frm_tagm_create');
  switch(m)
  {
    case 'tag_manager':
      document.getElementById('tagm_create').style.display = "none";
      document.getElementById('tagm_manage').style.display = "block";
      tagm_f.reset();
      break;
    case 'create_elem':
      document.getElementById('tagm_manage').style.display = "none";
      document.getElementById('tagm_create').style.display = "block";
      tagm_f.tagm_name.focus();
      break;
  }
}

function tagm_togglepg(Caller)
{
  var label_t='_title', label_b='_body';
  var c_body = document.getElementById(Caller.id.substring(0,Caller.id.length-label_t.length+1) + label_b);
  with(c_body.style)
  {
    if(display == 'none' || display.length == 0) { display = 'block'; Caller.className = 'csspg_t1'; }
    else { display = 'none'; Caller.className = 'csspg_t0'; }
  }
}

var RE = new Array();
RE.hex = /\#([a-f0-9]{6})/i;
RE.units = /([0-9]+)px/i;

/**
 * object CML_Elem(string, string, string, string, bool, AArray)
 * Sub-class for CML_ElemHandler-class.
 * (CML = Custom Markup Language)
 */
var CSS_RULE_PREFIX = 'CMLR_';
function CML_Elem(eType, eName, eCss, html_eName, isEmpty, availProps)
{
  this.touched      = false;          // Shows whether the object has been touched or if it's "fresh".
  this.type         = eType;          // Element name.
  this.name         = eName;          // Element type (id or class).
  this.cssStr       = eCss;           // Element CSS property string.
  this.cssProps     = new AArray();   // Element CSS property associative array (AArray).
  this.cssUpdated   = false;          // Indicator for determining whether css has been updated since last property change or not.
  this.isEmpty      = isEmpty;        // Empty element or not: <elem /> or <elem> ... </elem>
  this.htmlElemName = html_eName;     // HTML element for representing the CML element.
  
  this.availProps = availProps;       // Available (changeable) properties, a string of names and name-groups separated by ,-character.
  this.availPropsChanged = false;
  
  this.cssRuleIndex = -1; // Not used in IE...
  
  /**
   * string getCssProp(string, bool)
   */
  this.getCssProp = function(nam, rmSymbols)
  {
    if(this.cssProps.isset(nam))
      return (rmSymbols ? this.cssProps.get(nam).replace(/px|\#|%|transparent/, '') : this.cssProps.get(nam));
    else
      return null;
  };
  
  /**
   * void setCssProp(string, string [, bool])
   * Sets or changes a css property.
   */
  this.setCssProp = function(pNam, pVal, update)
  {
    this.touched = true;
    this.cssUpdated = false;
    
    // Update available properties.
    if(this.getCssProp(pNam) != pVal)
    {
      switch(pNam)
      {
        case 'position':
          if(pVal == 'relative' || pVal == 'static')
          {
            this.availProps.set('top', false);
            this.availProps.set('left', false);
          }
          else // position:absolute
          {
            if(this.getCssProp('top') == null)
              this.setCssProp('top','0px');
            if(this.getCssProp('left') == null)
              this.setCssProp('left','0px');
            
            this.availProps.set('top', true);
            this.availProps.set('left', true);
          }
          break;
      }
      this.availPropsChanged = true;
    }
    else
    {
      this.availPropsChanged = false;
    }
    
    this.cssProps.set(pNam, pVal);
    
    if(update)
      this.updateCss();
  };
  this.hej = 0;
  /**
   * bool updateCss()
   * Updates css string if it's not up to date. Returns true if any CSS-rules has been applied and false otherways.
   */
  this.updateCss = function()
  {
    if(this.cssUpdated)
      return false;
    
    var pVal, str = '';
    var width = null, height = null, wOffset = 0, hOffset = 0;
    var AA;
    while(AA = this.cssProps.foreach('n','v'))
    {
      pNam = AA.n;
      pVal = AA.v;
      
      if(this.availProps.get(pNam) === false)
        continue;
      
      if(pNam.length && pVal.length)
      {
        // ## Collect relevant property values for the box dimensions (if not msie box model).
        if(B.ie)
        {
          str += pNam + ':' + pVal + ';';
        }
        else // Browser case: Gecko/Firefox right now...
        {
          switch(pNam)
          {
            // Collect data for browser-dependent resizing.
            case 'width':
              width = parseInt(pVal);
              break;
            case 'height':
              height = parseInt(pVal);
              break;
            
            case 'padding':
            case 'border-width':
              wOffset += (parseInt(pVal)*2);
              hOffset += (parseInt(pVal)*2);
            
            default:
              str += pNam + ':' + pVal + ';';
          }
        }
      }
    }
    
    // ## Resize width and height according to the IE-way (which means: absolute width and height, independent of padding, margins etc).
    if(!B.ie)
    {
      if(width != null && width > wOffset)
      {
        width -= wOffset;
        str += 'width:' + width + 'px;';
      }
      if(height != null && height > hOffset)
      {
        height -= hOffset;
        str += 'height:' + height + 'px;';
      }
    }
    
    if(str.length > 0)
    {
      this.cssUpdated = true;
      this.cssStr = str.substr(0, str.length-1);
      
      var rNam = (this.type == 'id' ? '#' : this.htmlElemName + '.') + CSS_RULE_PREFIX + this.name;
      
      with(document.styleSheets[0])
      {
        disabled = false;
        
        if(B.ie)
        {
          var rIdx = null;
          for(var ruleIdx=rules.length-1; ruleIdx>-1; ruleIdx--)
          {
            // Find rule index (the rule we want to update).
            if(rNam.toLowerCase() == rules[ruleIdx].selectorText.toLowerCase())
            {
              rIdx = ruleIdx;
              break;
            }
          }
          
          if(rIdx != null)
            removeRule(rIdx);
          
          addRule(rNam, this.cssStr);
        }
        else
        {
          var idx = cssRules.length;
          if(this.cssRuleIndex != -1)
          {
            idx = this.cssRuleIndex;
            deleteRule(this.cssRuleIndex);
          }
          
          this.cssRuleIndex = insertRule(rNam + '{' + this.cssStr + '}', idx);
        }
      }
      
      return true;
    }
    else { return false; }
  };
  
  /**
   * string getCssStr()
   * Returns CSS string.
   */
  this.getCssStr = function()
  {
    this.updateCss();
    return this.cssStr;
  };
  
  /**
   * string getDetachedCss()
   * Returns CSS as id or class entity string: #elem{props} or htmlElem.elem{props}
   */
  this.getDetachedCss = function()
  {
    this.updateCss();
    return (this.type == 'id' ? '#' : this.htmlElemName + '.') + this.name + '{' + this.cssStr + '}\n';
  };
  
  /**
   * mixed compileStartElem()
   * Returns - if type != id - ready to use HTML start-element containing (if available) a style-attribute with the CSS string inside of it,
   * otherways false.
   */
  this.compileStartElem = function(attrs)
  {
    if(this.type == 'class')
      return '<' +
               this.htmlElemName + (this.updateCss() || this.cssUpdated ? ' class="' + CSS_RULE_PREFIX + this.name + '"' : '') +
               (attrs.length ? attrs : '') +
               (this.isEmpty ? ' /' : '') +
             '>';
    else
      return false;
  };
  
  /**
   * mixed compileEndElem()
   * Returns ready to use HTML end-element if the element isn't an "empty element", otherways false.
   */
  this.compileEndElem = function()
  {
    if(!this.isEmpty && this.type == 'class') return '</' + this.htmlElemName + '>';
    else { return false; }
  };
  
  
  // ## On create (constructor functionality):
  
  // Import pre-defined css into property array.
  var pToks = this.cssStr.split(';');
  var pNam, pVal;
  for(var i=0, ii=pToks.length; i<ii; i++)
  {
    pNam = pToks[i].substr(0,pToks[i].indexOf(':'));
    pVal = pToks[i].substr(pNam.length+1);
    
    this.setCssProp(pNam, pVal, false);
  }
  
  // Update css string.
  this.updateCss();
  
  return this;
}

function CML_FProp(nam,BlockElem,InpElem)
{
  this.name = nam;
  this.BElem = BlockElem;
  this.IElem = InpElem;
  
  this.show = function() { this.BElem.style.display = 'block'; };
  this.hide = function() { this.BElem.style.display = 'none'; };
}

/**
 * object CML_ElemHandler()
 */
var APSC = new AArray(); // Available Property Group Shortcuts.
  APSC.set('BGR', 'background-color');
  APSC.set('FGR', 'color');
  APSC.set('MRG', 'margin-left,margin-right,margin-top,margin-bottom');
  APSC.set('LTA', 'display,position,top,left,width,height,padding');
  APSC.set('BRD', 'border-width,border-style,border-color');
  APSC.set('TXT', 'font-family,font-size,font-weight,font-style,text-decoration');
function CML_ElemHandler(Form)
{
  this.F = Form;
  this.F_Props = new AArray();
  
  this.cssInpPropIdPrefix = 'cssp_';
  this.cssFrmPropIdPrefix = 'div__p_';  // String used to prefix property groups and individuals.
  this.CElem = null;                    // Current CML_Elem object.
  this.Elems = new AArray();            // Elements associative array.
  this.elemsUpdated = false;
  
  this.addElem = function(actualElemName, type, name, isEmpty, css, availProps)
  {
    // Element is already defined.
    if(this.Elems.isset(name))
      return false;
    
    // Element name is not valid.
    else if(!name.match(/^[a-z0-9_:]+$/i))
      return false;
    
    var AA_AP = new AArray();
    
    // Element is valid.
    if(availProps != null)
    {
      var ap = availProps.split(',');
      for(var i=0, ii=ap.length; i<ii; i++)
      {
        if(ap[i].substr(3,1) == '*')
        {
          ap[i] = APSC.get(ap[i].substr(0,3)).split(',');
          for(var j=0, jj=ap[i].length; j<jj; j++)
            AA_AP.set(ap[i][j], true, true);
        }
        else
        {
          AA_AP.set(ap[i], true, true);
        }
      }
    }
    
    this.Elems.set(name, new CML_Elem(type,name,css,actualElemName,isEmpty,AA_AP));
    
    this.elemsUpdated = false;
    
    return true;
  };
  
  /**
   * bool setCss(object, string)
   *
   * @param object caller
   */
  this.setCss = function(Caller, pNam)
  {
    var pVal = Caller.value;                               // Suggested CSS property value (=not checked).
    var current_pVal = this.CElem.getCssProp(pNam, true);  // Shortcut to current CSS property value.
    
    // ## Check value and add symbols(#), units(px), aliases(transparent) to relevant css properties.
    switch(pNam)
    {
      // Colors:
      case 'background-color':
      case 'border-color':
      case 'color':
        if(pVal.match(/[a-f0-9]{6}/i)) { pVal = '#' + pVal; }
        else if(pVal.length == 0)      { pVal = 'transparent'; }
        else                           { if(pVal.length >= 6) Caller.value = (current_pVal != null ? current_pVal : ''); return false; }
        break;
      
      // Dimensions (positive numbers):
      case 'height':
      case 'width':
        if(pVal.match(/[0-9]+/))    { pVal = pVal + 'px'; }
        else if(pVal.length == 0)   { pVal = 'auto'; }
        else                        { Caller.value = (current_pVal != null ? current_pVal : Caller.getAttribute('value')); return false; }
        break;
      
      // Positioning (positive and negative numbers):
      case 'top':
      case 'left':
      case 'margin-left':
      case 'margin-right':
      case 'margin-top':
      case 'margin-bottom':
        if(pVal.match(/-?[0-9]+/))  { pVal = pVal + 'px'; }
        else                        { Caller.value = (current_pVal != null ? current_pVal : Caller.getAttribute('value')); return false; }
        break;
      
      // Other numeric values (only positive numbers):
      case 'padding':
      case 'border-width':
      case 'font-size':
        if(pVal.match(/[0-9]+/))  { pVal = pVal + 'px'; }
        else                      { Caller.value = (current_pVal != null ? current_pVal : Caller.getAttribute('value')); return false; }
        break;
    }
    
    this.CElem.setCssProp(pNam, pVal, true);
    if(this.CElem.availPropsChanged)
      this.updateGUI(this.CElem.name, true);
    return true;
  };
  
  /**
   * void updateGUI(string, bool)
   */
  this.updateGUI = function(elemName, force)
  {
    // Check if we need to update.
    if(force !== true && (!this.Elems.isset(elemName) || (this.CElem != null && this.CElem.name == elemName)))
      return false;
    
    // Set current elem.
    this.CElem = this.Elems.get(elemName);
    
    // Reset form.
    this.F.reset();
    
    // ## Load select options (tags and id's).
    var SEL_elem = document.getElementById('sel_elem');
    if(!this.elemsUpdated)
    {
      SEL_elem.options.length = 0;
      var AA, i=0;
    	while(AA = this.Elems.foreach('elemName','Elem'))
        SEL_elem.options[i++] = new Option((AA.Elem.type == 'id' ? AA.elemName : '<'+AA.elemName+'>'), AA.elemName);
      
      this.elemsUpdated = true;
    }
    SEL_elem.value = elemName;
    
    // ## Import css property values into corresponding form elements.
    var pNam, pVal, pCont, AA;
    while(AA = this.CElem.cssProps.foreach('n','v'))
    {
      pNam = AA.n.replace(/-/g, '');
      pVal = AA.v;
      
      if(pNam.length > 0)
      {
        // Remove # from hex-colors.
        if(pVal.match(RE.hex))
          pVal = pVal.replace(RE.hex, RegExp.$1);
        
        // Remove units from numbers.
        else if(pVal.match(RE.units))
          pVal = pVal.replace(RE.units, RegExp.$1);
        
        // Remove string:'transparent' and string:'auto' from color values.
        else if(pVal == 'transparent' || pVal == 'auto')
          pVal = '';
        
        // Check if we have a container for current property and change it if so is the case.
        if(this.F_Props.isset(pNam))
          this.F_Props.get(pNam).IElem.value = pVal;
      }
    }
    
    // Hide all form properties by default.
    var AA;
    while(AA = this.F_Props.foreach('n','FP'))
      AA.FP.hide();
    
    // Show wanted form properties.
    var AA, pNam;
    while(AA = this.CElem.availProps.foreach('pNam','isAvail'))
    {
      if(AA.isAvail)
      {
        pNam = AA.pNam.replace(/-/g, '');
        this.F_Props.get(pNam).show();
      }
    }
    
    return true;
  };
  
  // ## Construct routines (constructor):
  
  // Import Form CSS Properties.
  var fpNam, FPInp;
  var FProps = this.F.getElementsByTagName('div'), FP;
  for(var i=0, ii=FProps.length; i<ii; i++)
  {
    FP = FProps[i];
    if(FP.id.substr(0,7) != this.cssFrmPropIdPrefix)
      continue;
    
    fpNam = FP.id.substr(7);
    FPInp = document.getElementById(this.cssInpPropIdPrefix + fpNam);
    this.F_Props.set(fpNam, new CML_FProp(fpNam, FP, FPInp), false);
  }
}

function cml_addElem()
{
  var f = document.getElementById('frm_tagm_create');
  if(EH.addElem('div', f.tagm_type.value, f.tagm_name.value, 0, CUSTOM_ELEM_PREPROPS, CUSTOM_ELEM_AVAILPROPS))
  {
    EH.updateGUI(f.tagm_name.value);
    f.reset();
    tagm_go('tag_manager');
  }
  else { alert(LANG__elem_name_not_valid); }
  
  pcpl();
}

function cml_update(Caller, cssPropName, forceCompile)
{
  EH.setCss(Caller,cssPropName);
  if(cssPropName == 'position' || forceCompile == true)
    CMLC.updatePreview();
}


/************************************************
 * Compiler Environment
 ***********************************************/

function pe_htmlentities(s)
{
  return s.replace(/</g, '&#60;').replace(/>/g, '&#62;');
}

/**
 * CML_Compiler()
 */
function CML_Compiler(C, P)
{
  this.DataCont  = C;    // Presentation data container (the textarea).
  this.PrevArea  = P;    // Presentation preview area (div-block).
  
  this.DebugElem = document.createElement('div');
  this.DebugElem.setAttribute('id', 'pe_debug');
  
  // ## Compiler trackers:
  this.tagStack     = new List();
  this.openTags     = new Array();
  this.regIds       = new AArray();
  this.errors       = new List();
  this.hasBodyStart = false;
  this.hasBodyEnd   = false;
  
  /**
   * void resetEnv();
   */
  this.resetEnv = function()
  {
    this.tagStack = new List();
    this.openTags = new Array();
    this.regIds   = new AArray();
    this.errors.clear();
    this.hasBodyStart = false;
    this.hasBodyEnd   = false;
  };
  
  /**
   * bool openTag(CML_Elem)
   */
  this.openTag = function(cml)
  {
    if(typeof(cml) == 'undefined') return false;
    if(cml.isEmpty) return true;
    
    this.tagStack.push(cml.name);
    
    if(typeof(this.openTags[cml.name]) == 'undefined')
      this.openTags[cml.name] = 1;
    else
      this.openTags[cml.name]++;
    
    return true;
  };
  
  /**
   * bool registerId(string)
   *
   * Warning: typeof(this.regIds['some']) (and maybe other keys) will return 'function' in firefox. Therefore we're going to prefix these.
   * _OR_ use AArray object instead (as we do just now, and yes, it is a change)...
   */
  this.registerId = function(id)
  {
    if(!this.regIds.isset(id))
    {
      this.regIds.set(id, 1);
      return true;
    }
    else
    {
      this.err(LANG__err_id_already_used, new Array(id));
      return false;
    }
  };
  
  /**
   * bool tagIsOpen(string)
   */
  this.tagIsOpen = function(n)
  {
    return (typeof(this.openTags[n]) != 'undefined' && this.openTags[n] > 0);
  };
  
  /**
   * bool closeTag(CML_Elem)
   */
  this.closeTag = function(cml)
  {
    if(typeof(cml) == 'undefined') return false;
    
    if(this.tagIsOpen(cml.name) && this.tagStack.getLast() == cml.name)
    {
      this.tagStack.pop();
      this.openTags[cml.name]--;
      return true;
    }
    else if(!this.tagIsOpen(cml.name))
    {
      this.err(LANG__err_unnecessary_end_tag, new Array(cml.name));
      return false;
    }
    else
    {
      this.err(LANG__err_expecting_end_tag, new Array(this.tagStack.getLast(), cml.name));
      return false;
    }
  };
  
  this.err = function(msg, vals)
  {
    var re;
    for(var i=0, ii=vals.length; i<ii; i++)
    {
      re = new RegExp('\\$'+i);
      msg = msg.replace(re, '<span class="ped_msg_highlight">'+vals[i]+'</span>');
    }
    this.errors.push(msg);
  };
  
  this.hasError = function()
  {
    return (!this.errors.isEmpty());
  };
  
  this.dumpErrors = function(n)
  {
    var msg, msgs='';
    while(n-- > 0 && (msg = this.errors.shift()) !== false)
      msgs += '<div class="ped_msg"><span class="ped_msg_prefix">#</span> ' + msg + '</div>';
    this.DebugElem.innerHTML = msgs;
    this.PrevArea.appendChild(this.DebugElem);
  };
  
  this.updatePreview = function()
  {
    var c = this.makeCompile(true);
//    deb(pe_htmlentities(c),true);
    if(!this.hasError())
    {
      this.PrevArea.innerHTML = c;
    }
    else
    {
      this.PrevArea.innerHTML = '';
      this.dumpErrors(1);
    }
  };
  
  /**
   * string makeCompile(bool)
   */
  this.makeCompile = function(isPreview)
  {
    this.resetEnv();
    var c = this.DataCont.value;
    
    c = c.replace(/\|/gi, '&#124;');   // Replace all pipe characters with corresponding HTML entities (since these are used for separation below).
  	c = c.replace(/<{1}/gi, '|<');     // Mark all < characters.
  	c = c.replace(/>{1}/gi, '>|');     // Mark all > characters.
    
  	var re_attr = /\s?([a-z_][a-z0-9_]*=\".*?\")\s?/gi;
  	
    var isEndTag=false, tagFound=false, attrsFound=false;
    var tagName, attrs, attr, attrStr='', attrNam, attrVal;
    var id_attr = null;
    var compiled_str = '';
    var attrList = new List(); // Attribute list for storage of parsed attribute names and values.
    var E, t; // Shortcuts: E=EH.elems[tagName], t=tokens[i]
    var tokens = c.split(/\|{1,2}/);
    for(var i=0, ii=tokens.length; i<ii; i++)
    {
      t = tokens[i];
      
      // Reset current properties.
      tagFound = false;
      attrsFound = false;
      attrStr = '';
      id_attr = null;
      
      if(t.substr(0,1) == '<' && t.substr(t.length-1,1) == '>')
      {
        tagName = t.substr(1, t.length-2);
        isEndTag = (tagName.substr(0, 1) == '/');
        
        // Case: End-tag
        if(isEndTag)
        {
          tagName = tagName.substr(1);
        }
        // Case: Tag has attributes
        else if(tagName.indexOf(' ') != -1)
        {
          // ## Separate tag name from attribute string.
          attrs = tagName.substr(tagName.indexOf(' ')+1);
          attrs = attrs.replace(re_attr, '$1|');
          attrs = attrs.substr(0, attrs.length-1).split('|');
          tagName = tagName.substr(0, tagName.indexOf(' '));
          attrsFound = true;
        }
        
        E = EH.Elems.get(tagName); // Update shortcut.
        
        if(this.hasBodyStart)
        {
          // Start-tag found:
          if(!isEndTag && this.openTag(E))
          {
            tagFound = true;
            
            // Tag attributes found:
            if(attrsFound)
            {
              for(var attr_i=0, attr_len=attrs.length; attr_i<attr_len; attr_i++)
              {
                attr = attrs[attr_i];
                if(!attr.match(re_attr)) continue;
                
                attrNam = attr.substr(0, attr.indexOf('='));
                attrVal = attr.substring(attr.indexOf('=')+2, attr.lastIndexOf('"'));
                
                switch(tagName)
                {
                  case 'a':
                    switch(attrNam)
                    {
                      case 'href':
                        if(attrVal.length > 3)
                          attrList.push(new Array('href', attrVal));
                    }
                    attrList.push(new Array('target','_new'));
                    break;
                  
                  // Bypass standard non-modifable elements:
                  case 'b':
                  case 'i':
                  case 's':
                  case 'u':
                  case 'center':
                  case 'right':
                  case 'big':
                  case 'br':
                    break;
                  
                  default:
                    switch(attrNam)
                    {
                      case 'id':
                        if(this.registerId(attrVal))
                        {
                          // Make the id-element inherit its properties fron its parent (class-element).
                          if(EH.Elems.isset(attrVal))
                          {
                            var E_id = EH.Elems.get(attrVal);
                            
                            // Make sure we don't inherit anything if the properties of the ID-element has been changed.
                            if(!E_id.touched)
                            {
                              E_id.cssProps = new ObjClone(E.cssProps);
                              E_id.updateCss();
                            }
                          }
                          
                          // Register id attribute.
                          attrList.push(new Array('id', CSS_RULE_PREFIX + attrVal));
                          
                          // Save ID temporarily for possible use below.
                          id_attr = attrVal;
                        }
                        break;
                    }
                }
              }
            }
            
            // Add preview attributes.
            if(isPreview)
            {
              switch(tagName)
              {
                // Bypass standard and not-wanted elements:
                case 'a':
                case 'b':
                case 'i':
                case 's':
                case 'u':
                case 'center':
                case 'right':
                case 'big':
                case 'br':
                  break;
                
                default:
                  if(id_attr != null)
                  {
                    if(E_id.getCssProp('position') == 'absolute')
                    {
                      attrList.push(new Array('onmousedown',  'Box.start(event, this,\''+id_attr+'\');'));
                      attrList.push(new Array('onmouseup',    'Box.end();'));
                      attrList.push(new Array('onclick',      'EH.updateGUI(\''+id_attr+'\');event.cancelBubble=true;'));
//                      attrList.push(new Array('onmouseout',  'Box.end();'));
                    }
                    else
                    {
                      attrList.push(new Array('onclick',  'EH.updateGUI(\''+id_attr+'\');event.cancelBubble=true;'));
                    }
                    attrList.push(new Array('title', '&#60;' + tagName + ' id=&#34;' + id_attr + '&#34;&#62;'));
                  }
                  else
                  {
                    attrList.push(new Array('onclick',  'EH.updateGUI(\''+tagName+'\');event.cancelBubble=true;'));
                    attrList.push(new Array('title', '&#60;'+tagName+'&#62;'));
                  }
              }
            }
            
            // Build attribute string.
            while((attr = attrList.pop()) !== false)
              attrStr += ' ' + attr[0] + '="' + attr[1] + '"';
            
            compiled_str += E.compileStartElem(attrStr);
          }
          // End-tag found:
          else if(this.closeTag(E) && !E.isEmpty)
          {
            tagFound = true;
            compiled_str += E.compileEndElem();
            
            if(tagName == 'body')
            {
              this.hasBodyEnd = true;
              break;
            }
          }
        }
        
        // We have either the <body> or the </body> tag.
        else if(tagName == 'body')
        {
          // Case: <body>
          if(!isEndTag)
          {
            if(this.hasBodyStart)
              this.err(LANG__err_too_many_body_start);
            else
              this.openTag(E);
            
            compiled_str += E.compileStartElem(' onclick="EH.updateGUI(\''+tagName+'\');"');
            this.hasBodyStart = true;
          }
          // Case: </body>
          else
          {
            compiled_str += E.compileEndElem();
            this.closeTag(E);
          }
          
          continue;
        }
        
        // Check if we have a <body> tag, if not: store error message and continue.
        else
        {
          this.err(LANG__err_missing_body_start);
          continue;
        }
        
      }
      
      if(!tagFound && this.hasBodyStart)
        compiled_str += pe_htmlentities(t);
    }
  	
    return compiled_str;
  };
  
  return this;
}


/* ###
 * ### WYSIWYG-functions:
 * ### */

function routeBodyMove(e)
{
  var Ev = new Event(e);
  Ev.cancelBubble=true;
  Box.moveTo(Ev.pageOffsetX, Ev.pageOffsetY);
//  deb('('+Ev.pageOffsetX+', '+Ev.pageOffsetY+')',true);
}

/**
 * Object BoxManager()
 * 
 */
function BoxManager()
{
  this.offsetX;
  this.offsetY;
  this.objX;
  this.objY;
  this.pX;
  this.pY;
  
  this.Elem;
  this.HtmlObj;
  this.Ev;
  this.doMove = false;
  this.hasMoved = false;
  
  this.cssBak = new List(); // Store original CSS-values while replacing them with temporary values.
  
  this.start = function(e, html_o,cml_nam)
  {
    this.Ev = new Event(e);
    this.Elem = EH.Elems.get(cml_nam);
    
    this.objX = this.Ev.objPosX;
    this.objY = this.Ev.objPosY;
    
    this.offsetX = parseInt(this.Elem.getCssProp('left')) - (this.Ev.pageOffsetX);
    this.offsetY = parseInt(this.Elem.getCssProp('top')) - (this.Ev.pageOffsetY);
    
    this.HtmlObj = html_o;
    this.doMove = true;
    this.hasMoved = false;
    
//    this.cssBak.push(new Array('z-index', this.Elem.getCssProp('z-index')));
    this.cssBak.push(new Array('z-index', 'auto'));
    
    if(this.Elem.getCssProp('cursor') == null)
      this.cssBak.push(new Array('cursor', 'default'));
    else
      this.cssBak.push(new Array('cursor', this.Elem.getCssProp('cursor')));
    
    this.Elem.setCssProp('cursor', 'move', true); // Do not change the order of this.
    this.Elem.setCssProp('z-index', '1000', true);
  };
  
  this.moveTo = function(x,y)
  {
    if(this.doMove)
    {
      this.pX = this.offsetX + x;
      this.pY = this.offsetY + y;
      deb('('+this.pX+', '+this.pY+')',true); // TESTER
      this.HtmlObj.style.left = (this.pX) + 'px';
      this.HtmlObj.style.top = (this.pY) + 'px';
      this.hasMoved = true;
      if(B.ie) document.getElementById('inp_HEX').focus();
    }
  };
  
  this.end = function()
  {
    this.doMove = false;
    var css_prop;
    
    // Reset temporary css-changes.
    while((css_prop = this.cssBak.pop()) !== false)
      if(css_prop[1] != null)
        this.Elem.setCssProp(css_prop[0], css_prop[1]);
    
    // Change position if box has moved.
    if(this.hasMoved)
    {
      this.Elem.setCssProp('top', this.pY + 'px');
      this.Elem.setCssProp('left', this.pX + 'px');
      EH.updateGUI(this.Elem.name, true);
    }
    else
    {
      this.Elem.updateCss();
    }
  };
}


// Debug function...
function deb(str,doClear)
{
  var str = (doClear !== true ? document.getElementById('deb').innerHTML : '') + str + '<br />';
  if(typeof(str) == 'string')
    document.getElementById('deb').innerHTML = str.replace(/\n/g, '<br />');
  else
    document.getElementById('deb').innerHTML = str;
}